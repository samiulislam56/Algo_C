1.// #include <stdio.h>
#include <time.h>

// ---------- Merge Sort ----------
void merge(int A[], int mid, int low, int high)
{
    int i, j, k, B[100];
    i = low;
    j = mid + 1;
    k = low;

    while (i <= mid && j <= high)
    {
        if (A[i] < A[j])
        {
            B[k] = A[i];
            i++;
            k++;
        }
        else
        {
            B[k] = A[j];
            j++;
            k++;
        }
    }
    while (i <= mid)
    {
        B[k] = A[i];
        k++;
        i++;
    }
    while (j <= high)
    {
        B[k] = A[j];
        k++;
        j++;
    }
    for (int m = low; m <= high; m++)
    {
        A[m] = B[m];
    }
}

void mergeSort(int A[], int low, int high)
{
    int mid;
    if (low < high)
    {
        mid = (low + high) / 2;
        mergeSort(A, low, mid);
        mergeSort(A, mid + 1, high);
        merge(A, mid, low, high);
    }
}

// ---------- Quick Sort ----------
int partition(int A[], int low, int high)
{
    int pivot = A[low];
    int i = low + 1;
    int j = high;
    int temp;

    do
    {
        while (A[i] <= pivot)
        {
            i++;
        }

        while (A[j] > pivot)
        {
            j--;
        }

        if (i < j)
        {
            temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
    } 
    while (i < j);

    // Swap A[low] and A[j]
    temp = A[low];
    A[low] = A[j];
    A[j] = temp;
    return j;
}

void quickSort(int A[], int low, int high)
{
    int partitionIndex; // Index of pivot after partition

    if (low < high)
    {
        partitionIndex = partition(A, low, high);
        quickSort(A, low, partitionIndex - 1);  // sort left subarray
        quickSort(A, partitionIndex + 1, high); // sort right subarray
    }
}


// ---------- Helper Function ----------
void printArray(int *A, int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("%d ", A[i]);
    }
    printf("\n");
}

// ---------- Main ----------
int main()
{
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr1[n], arr2[n];

    printf("Enter array elements: ");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr1[i]);
        arr2[i] = arr1[i]; // copy array for quick sort
    }

    clock_t start, end;
    double time_taken;

    // Merge Sort
    start = clock();
    mergeSort(arr1, 0, n - 1);
    end = clock();
    time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("\nMerge Sort Result: ");
    printArray(arr1, n);
    printf("Merge Sort Time: %.5f sec\n", time_taken);

    // Quick Sort
    start = clock();
    quickSort(arr2, 0, n - 1);
    end = clock();
    time_taken = ((double)(end - start)) / CLOCKS_PER_SEC;

    printf("Quick Sort Result: ");
    printArray(arr2, n);
    printf("Quick Sort Time: %.5f sec\n", time_taken);

return 0;
}

-------------------------------------------------------------2.//--------------------------------------------------------------------------------------

#include<stdio.h>
#include<stdlib.h>

#define MAX 100

int adj[MAX][MAX];
int visited[MAX];
int n, m; // number of vertices, edges
int source, target;

// ==== DFS ====
int foundDFS = 0;
void DFS(int u) {
    printf("%d ", u);
    if (u == target) foundDFS = 1;
    visited[u] = 1;
    for (int v = 0; v < n; v++) {
        if (adj[u][v] && !visited[v])
            DFS(v);
    }
}

// ==== BFS ====
struct queue {
    int size, f, r, *arr;
};

int isEmpty(struct queue *q) { return q->f == q->r; }
void enqueue(struct queue *q, int val) { q->arr[++q->r] = val; }
int dequeue(struct queue *q) { return q->arr[++q->f]; }

int foundBFS = 0;
void BFS(int start) {
    struct queue q;
    q.size = MAX;
    q.f = q.r = -1;
    q.arr = (int*) malloc(q.size * sizeof(int));

    int vis[MAX] = {0};
    enqueue(&q, start);
    vis[start] = 1;

    while (!isEmpty(&q)) {
        int u = dequeue(&q);
        printf("%d ", u);
        if (u == target) foundBFS = 1;
        for (int v = 0; v < n; v++) {
            if (adj[u][v] && !vis[v]) {
                enqueue(&q, v);
                vis[v] = 1;
            }
        }
    }
    free(q.arr);
}

int main() {
    printf("Enter number of vertices: ");
    scanf("%d", &n);
    printf("Enter number of edges: ");
    scanf("%d", &m);

    // initialize adj matrix
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            adj[i][j] = 0;

    printf("Enter edges:\n");
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        adj[u][v] = adj[v][u] = 1; // undirected
    }

    printf("Enter source node: ");
    scanf("%d", &source);
    printf("Enter target node: ");
    scanf("%d", &target);

    // DFS
    for (int i = 0; i < n; i++) visited[i] = 0;
    printf("\nDFS Traversal: ");
    DFS(source);
    printf("\n");

    // BFS
    printf("BFS Traversal: ");
    BFS(source);
    printf("\n");

    printf("Path exists from %d to %d (DFS): %s\n", source, target, foundDFS ? "Yes" : "No");
    printf("Path exists from %d to %d (BFS): %s\n", source, target, foundBFS ? "Yes" : "No");

    return 0;
}


 -------------------------------------------------------------------------------------//3.--------------------------------------------------------

#include <stdio.h>
#include <limits.h>

#define V 14           // Number of campus locations
#define INF 99999      // Representation of infinity

// Structure to store edges
struct Edge {
    int src, dest, weight;
};

// Campus location names
const char *locationNames[V] = {
    "Admission Office",      // Node 0
    "AB-4",                  // Node 1
    "Food Court",            // Node 2
    "Gym",                   // Node 3
    "Medical Center",        // Node 4
    "Engineering Building",  // Node 5
    "Green Garden",          // Node 6
    "Central Mosque",        // Node 7
    "AB-1",                  // Node 8
    "Innovation Lab",        // Node 9
    "Rowsonara Hall",        // Node 10
    "YKSG-2",                // Node 11
    "Transport",             // Node 12
    "YKSG-1"                 // Node 13
};

// Dijkstra's Algorithm (non-negative edges)
void dijkstra(int graph[V][V], int src) {
    int dist[V], visited[V];

    for (int i = 0; i < V; i++) {
        dist[i] = INF;
        visited[i] = 0;
    }
    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int min = INF, u = -1;
        for (int v = 0; v < V; v++)
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                u = v;
            }

        visited[u] = 1;

        for (int v = 0; v < V; v++)
            if (!visited[v] && graph[u][v] != INF && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printf("\nDijkstra's Algorithm (No negative edges):\n");
    printf("Node\tDistance\tLocation Name\n");
    printf("----\t--------\t--------------\n");
    for (int i = 0; i < V; i++)
        printf("%d\t\t\t%d\t\t%s\n", i, dist[i], locationNames[i]);
}

// Bellman-Ford Algorithm (handles negative edges)
void bellmanFord(struct Edge edges[], int edgeCount, int src) {
    int dist[V];
    for (int i = 0; i < V; i++)
        dist[i] = INF;
    dist[src] = 0;

    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < edgeCount; j++) {
            int u = edges[j].src;
            int v = edges[j].dest;
            int weight = edges[j].weight;
            if (dist[u] != INF && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }

    // Check for negative-weight cycles
    int negativeCycleFound = 0;
    for (int j = 0; j < edgeCount; j++) {
        int u = edges[j].src;
        int v = edges[j].dest;
        int weight = edges[j].weight;
        if (dist[u] != INF && dist[u] + weight < dist[v]) {
            negativeCycleFound = 1;
            break;
        }
    }

    printf("\nBellman-Ford Algorithm (Handles negative edges):\n");
    printf("Node\tDistance\tLocation Name\n");
    printf("----\t--------\t--------------\n");
    for (int i = 0; i < V; i++)
        printf("%d\t\t\t%d\t\t%s\n", i, dist[i], locationNames[i]);
}

int main() {
    // Graph for Dijkstra (no negative edges, second diagram)
    int graph[V][V];
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            graph[i][j] = INF;

    // Set up connections based on the image
    // Admission office connections
    graph[0][1] = 3;
    graph[0][6] = 9;

    // AB-4 connections
    graph[1][0] = 3;
    graph[1][2] = 13;

    //Food-Court connections
    graph[2][1] = 13;
    graph[2][3] = 5;

    //Gym connections
    graph[3][2] = 5; // Central
    graph[3][4] = 8;


    // Medical_Center connections
    graph[4][3] = 8;
    graph[4][11] = 10;

    //EngineeringBuilding connections
    graph[5][11] = 7;

    // Green_Garden connections
    graph[6][7] = 6;
    graph[6][0] = 9;

    // Central_Mosque connections
    graph[7][6] = 6;
    graph[7][8] = 5;//cost unknown

    //AB-1 connections
    graph[8][7] = 5;
    graph[8][9] = 1;
    graph[8][12] = 4;

    //Innovation_Lab connections
    graph[9][8] = 1;
    graph[9][10] = 12;

    // Rowsonara_Hall connections
    graph[10][9] = 12;
    graph[10][11] = 15;

    //YKSG-2connections
    graph[11][5] = 7;
    graph[11][4] = 10;
    graph[11][10] = 15;

    //Transport connections
    graph[12][8]= 4;
    graph[12][13]= 2;

    //YKSG-1 connections
    graph[13][12]= 2;

    // Run Dijkstra
    dijkstra(graph, 0);

    // Edges for Bellman-Ford (with negatives, first diagram)
    struct Edge edges[] = {
        {0,1,3},{0,6,9},{1,0,3},{1,2,13},{2,1,13},
        {2,3,5},{3,2,5},{3,4,8},{4,3,8},{4,11,-10},
        {5,11,7},{6,7,6},{6,0,9},{7,6,6},{7,8,5},
        {8,7,5},{8,9,-2},{8,12,4},{9,8,1},{9,10,12},
        {10,9,12},{10,11,15},{11,5,-3},{11,4,10},{11,10,15},
        {12,8,4},{12,13,2},{13,12,2}
    };
    int edgeCount = sizeof(edges)/sizeof(edges[0]);

    // Run Bellman-Ford
    bellmanFord(edges, edgeCount, 0);

return 0;
}